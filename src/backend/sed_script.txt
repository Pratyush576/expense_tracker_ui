s/  const \[selectedYearDashboard, setSelectedYearDashboard\] = useState(new Date().getFullYear().toString()); \/\/ New state for dashboard year filter

  useEffect(() => {
    \/\/ Fetch expenses, income, and settings from the backend
    axios.get('http:\/\/localhost:8000\/api\/expenses', { params: { excluded_categories: excludedCategories } })
      .then(response => {
        \/\/ Add a unique ID to each transaction for easier manipulation
        const allTransactionsWithId = \[...response.data.income, ...response.data.expenses\].map((t, index) => ({
          ...t,
          id: `${t.Date}-${t.Description}-${t.Amount}-${t\['Payment Source'\]}-${index}` \/\/ Simple unique ID
        }));

        const filteredIncome = allTransactionsWithId.filter(t => t.Amount >= 0);
        const filteredExpenses = allTransactionsWithId.filter(t => t.Amount < 0);

        console.log("App.js - filteredIncome:", filteredIncome);
        console.log("App.js - filteredExpenses:", filteredExpenses);

        setIncome(filteredIncome);
        setExpenses(filteredExpenses); \/\/ Keep expenses state for ExpenseTable
        setSettings(response.data.settings);
      })
      .catch(error => {
        console.error('Error fetching data: ', error);
      });

    \/\/ Fetch category cost data for the pie chart
    axios.get('http:\/\/localhost:8000\/api\/category_costs', { params: { year: selectedYearDashboard, excluded_categories: excludedCategories } })
      .then(response => {
        if (Array.isArray(response.data)) {
          setCategoryCostData(response.data);
        } else {
          console.error('Error fetching category cost data: response data is not an array', response.data);
          setCategoryCostData(\[\]);
        }
      })
      .catch(error => {
        console.error('Error fetching category cost data: ', error);
      });

    \/\/ Fetch monthly category expenses data for the line and stacked bar charts
    axios.get('http:\/\/localhost:8000\/api\/monthly_category_expenses', { params: { year: selectedYearDashboard, excluded_categories: excludedCategories } })
      .then(response => {
        if (Array.isArray(response.data)) {
          const allMonthlyData = response.data;

          \/\/ Aggregate all monthly data to get total expenses per month
          const aggregatedMonthlyExpenses = allMonthlyData.reduce((acc, item) => {
            const { YearMonth, total_cost } = item;
            if (!acc\[YearMonth\]) {
              acc\[YearMonth\] = 0;
            }
            acc\[YearMonth\] += total_cost;
            return acc;
          }, {});

          \/\/ Convert to array of { YearMonth, total_cost }
          const monthlyAggregatedExpensesArray = Object.keys(aggregatedMonthlyExpenses).map(YearMonth => ({
            YearMonth,
            total_cost: aggregatedMonthlyExpenses\[YearMonth\]
          }));

          setMonthlyAggregatedExpenses(monthlyAggregatedExpensesArray);

          \/\/ Get all unique YearMonth values and sort them
          const uniqueMonthYears = \[...new Set(allMonthlyData.map(item => item.YearMonth))\].sort();

          \/\/ Get the last 12 unique month-year combinations
          const last12MonthYears = uniqueMonthYears.slice(Math.max(uniqueMonthYears.length - 12, 0));

          \/\/ Filter the data to include only the last 12 months and exclude categories in excludedCategories
          const filteredMonthlyData = allMonthlyData.filter(item =>
            last12MonthYears.includes(item.YearMonth) && !excludedCategories.includes(item.Category)
          );

          setMonthlyCategoryExpenses(filteredMonthlyData);
        } else {
          console.error('Error fetching monthly category expenses data: response data is not an array', response.data);
          setMonthlyAggregatedExpenses(\[\]);
          setMonthlyCategoryExpenses(\[\]);
        }
      })
      .catch(error => {
        console.error('Error fetching monthly category expenses data: ', error);
      });

    \/\/ Fetch payment sources for the filter dropdowns
    axios.get('http:\/\/localhost:8000\/api\/payment_sources')
      .then(response => {
        setPaymentSources(response.data);
      })
      .catch(error => {
        console.error('Error fetching payment sources:', error);
      });

  }, \[key, excludedCategories, selectedYearDashboard\]); \/\/ Add selectedYearDashboard to dependency array
/  const \[allTransactions, setAllTransactions\] = useState(\[\]);
  const \[selectedYearDashboard, setSelectedYearDashboard\] = useState(new Date().getFullYear().toString()); \/\/ New state for dashboard year filter

  useEffect(() => {
    \/\/ Fetch expenses, income, and settings from the backend
    axios.get('http:\/\/localhost:8000\/api\/expenses', { params: { excluded_categories: excludedCategories } })
      .then(response => {
        \/\/ Add a unique ID to each transaction for easier manipulation
        const allTransactionsWithId = \[...response.data.income, ...response.data.expenses\].map((t, index) => ({
          ...t,
          id: `${t.Date}-${t.Description}-${t.Amount}-${t\['Payment Source'\]}-${index}` \/\/ Simple unique ID
        }));
        setAllTransactions(allTransactionsWithId);
        setSettings(response.data.settings);
      })
      .catch(error => {
        console.error('Error fetching data: ', error);
      });

    \/\/ Fetch payment sources for the filter dropdowns
    axios.get('http:\/\/localhost:8000\/api\/payment_sources')
      .then(response => {
        setPaymentSources(response.data);
      })
      .catch(error => {
        console.error('Error fetching payment sources:', error);
      });

  }, \[key, excludedCategories\]); \/\/ Remove selectedYearDashboard from dependency array

  useEffect(() => {
    const filteredTransactions = allTransactions.filter(t => new Date(t.Date).getFullYear().toString() === selectedYearDashboard);
    const filteredIncome = filteredTransactions.filter(t => t.Amount >= 0);
    const filteredExpenses = filteredTransactions.filter(t => t.Amount < 0);

    console.log("App.js - filteredIncome:", filteredIncome);
    console.log("App.js - filteredExpenses:", filteredExpenses);

    setIncome(filteredIncome);
    setExpenses(filteredExpenses); \/\/ Keep expenses state for ExpenseTable

    \/\/ Fetch category cost data for the pie chart
    axios.get('http:\/\/localhost:8000\/api\/category_costs', { params: { year: selectedYearDashboard, excluded_categories: excludedCategories } })
      .then(response => {
        if (Array.isArray(response.data)) {
          setCategoryCostData(response.data);
        } else {
          console.error('Error fetching category cost data: response data is not an array', response.data);
          setCategoryCostData(\[\]);
        }
      })
      .catch(error => {
        console.error('Error fetching category cost data: ', error);
      });

    \/\/ Fetch monthly category expenses data for the line and stacked bar charts
    axios.get('http:\/\/localhost:8000\/api\/monthly_category_expenses', { params: { year: selectedYearDashboard, excluded_categories: excludedCategories } })
      .then(response => {
        if (Array.isArray(response.data)) {
          const allMonthlyData = response.data;

          \/\/ Aggregate all monthly data to get total expenses per month
          const aggregatedMonthlyExpenses = allMonthlyData.reduce((acc, item) => {
            const { YearMonth, total_cost } = item;
            if (!acc\[YearMonth\]) {
              acc\[YearMonth\] = 0;
            }
            acc\[YearMonth\] += total_cost;
            return acc;
          }, {});

          \/\/ Convert to array of { YearMonth, total_cost }
          const monthlyAggregatedExpensesArray = Object.keys(aggregatedMonthlyExpenses).map(YearMonth => ({
            YearMonth,
            total_cost: aggregatedMonthlyExpenses\[YearMonth\]
          }));

          setMonthlyAggregatedExpenses(monthlyAggregatedExpensesArray);

          \/\/ Get all unique YearMonth values and sort them
          const uniqueMonthYears = \[...new Set(allMonthlyData.map(item => item.YearMonth))\].sort();

          \/\/ Get the last 12 unique month-year combinations
          const last12MonthYears = uniqueMonthYears.slice(Math.max(uniqueMonthYears.length - 12, 0));

          \/\/ Filter the data to include only the last 12 months and exclude categories in excludedCategories
          const filteredMonthlyData = allMonthlyData.filter(item =>
            last12MonthYears.includes(item.YearMonth) && !excludedCategories.includes(item.Category)
          );

          setMonthlyCategoryExpenses(filteredMonthlyData);
        } else {
          console.error('Error fetching monthly category expenses data: response data is not an array', response.data);
          setMonthlyAggregatedExpenses(\[\]);
          setMonthlyCategoryExpenses(\[\]);
        }
      })
      .catch(error => {
        console.error('Error fetching monthly category expenses data: ', error);
      });
  }, \[selectedYearDashboard, allTransactions, excludedCategories\]);
/g